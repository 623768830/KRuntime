
All Files 
    DONE - Edit -> Format Document
    DONE - Search and Replace: fRet -> fSuccess

    Dispose - declare on all classes
    Dispose - implement on all classes

    Check all function input params
    Check all function have valid return values

    Split Property get/set from Functions
    Move all local variable to start of function
    Initialize all variables
    check all pointers for null before calling pointer->function
    

End to End parse through code and add @@TODOs

Override Rules
 
  kdepend
 Rewrite as managed part of Loader
 
Very simple versioning, dependency, loading, servicing rules
Development time
----------------
Application specifics list of package references
Don’t collapsed NuGet packages

Deployment time
---------------
Application only deploys package references and not DLLs from NuGet packages (smart hoster) … deployment to simple hoster (FTP) will require all files

Runtime
-------
Load Highest Referenced Version
App run against exact bits it was compiled against (true side by side)
App only loads assemblies it truly needs

Updates and Servicing
---------------------
Regular updates in new package releases
Servicing – Zero Day 2 to 3 incidents in 2 year cycle
Override Rules

-eof





/*
bool HostCoreClr_Main(const int argc, const wchar_t* argv[], const bool verbose, const bool waitForDebugger, int &exitCode)
{
BOOL fSuccess = TRUE;
HRESULT hr = S_OK;
HMODULE hManagedExeModule = nullptr;
ICLRRuntimeHost2 *pHostICLRRuntimeHost2 = nullptr;
HostEnvironment *pHostEnvironment = NULL;
HostMainDelegate pHostMain = nullptr;
DWORD dwDomainId;

// Preset return arguments
// Assume failure
exitCode = -1;

pHostEnvironment = new HostEnvironment();
if (pHostEnvironment == NULL)
{
//@@TODO ASSERT
return false;
}

//-------------------------------------------------------------
// Find the specified exe. This is done using LoadLibrary so that
// the OS library search semantics are used to find it.

//@@ Assuming this is the "managed app exe" and not the "host exe"

const wchar_t* exeName = argc > 0 ? argv[0] : nullptr;
wchar_t managedExePath[MAX_PATH];
wchar_t* managedAssemblyToStart = managedExePath;

// Assume no argument was provided or the argument was too long or the 
// module could not be found or loaded.
managedExePath[0] = '\0';

if (exeName) 
{
// There's an exeName, but only use it if it isn't too long
auto exeNameLength = ::wcslen(exeName);

if (exeNameLength < MAX_PATH + 4) {

std::wstring managedExeArg(exeName);

TRACE_ODS1(L"Attempting to load: %s", managedExeArg);

// Have the OS loader discover the location of the managed exe
//@@jhawk- hmmm, this will trigger a file open ... 
//@@ also the paths may not be correct

//@@TODO - move to ClrDomainInstance
hManagedExeModule = ::LoadLibraryExW(managedExeArg.c_str(), NULL, 0);

if (!hManagedExeModule) {
TRACE_ODS1(L"Failed to load: %s", managedExeArg);
} 

// If the loader didn't discover the exe, it might require a .exe extension
// Only do this if there was not already a .exe extension.
if (!hManagedExeModule && 
managedExeArg[exeNameLength] != L'.' &&
(managedExeArg[exeNameLength + 1] != L'e' && managedExeArg[exeNameLength + 1] != L'E') &&
(managedExeArg[exeNameLength + 2] != L'x' && managedExeArg[exeNameLength + 2] != L'X') &&
(managedExeArg[exeNameLength + 3] != L'e' && managedExeArg[exeNameLength + 3] != L'E') ) 
{
managedExeArg += L".exe";

TRACE_ODS1(L"Attempting to load: %s", managedExeArg);
hManagedExeModule = ::LoadLibraryExW(managedExeArg.c_str(), NULL, 0);
}

if (!hManagedExeModule) {
TRACE_ODS1(L"Failed to load: %s",  managedExeArg);

return false;
}

// If the module was successfully loaded, get the path to where it was found.
::GetModuleFileNameW(hManagedExeModule, managedExePath, MAX_PATH);

std::wstring ws_ApplicationDirectoryPath(managedExePath);
TRACE_ODS1(L"Loaded: %s", managedExePath);

// Find the assembly name part
for (auto i = (int)::wcslen(managedExePath); i >= 0; i--) {
if (managedExePath[i] == L'\\') {
managedAssemblyToStart = managedExePath + i + 1;
managedExePath[i] = L'\0';
break;
}
}

ws_ApplicationDirectoryPath[(managedAssemblyToStart - managedExePath)] = L'\0';
TRACE_ODS1(L"ApplicationDirectoryPath: %s", ws_ApplicationDirectoryPath.c_str());

pHostEnvironment->SetApplicationPath(ws_ApplicationDirectoryPath.c_str());

std::wstring ws_ApplicationPackagesPath(ws_ApplicationDirectoryPath.c_str());
ws_ApplicationPackagesPath += L"packages";
ws_ApplicationPackagesPath += L"\\";
TRACE_ODS1(L"ApplicationPackagesPath: %s", ws_ApplicationPackagesPath.c_str());

pHostEnvironment->SetApplicationPackagesPath(ws_ApplicationPackagesPath.c_str());

//@@TODO should assert if list is full
//@@TODO add BOOL fEnabledAppend check

// Append Application Package cache directory to Package Caches
if (g_piKitePackagesPathsCount < g_cKitePackagesPathSearchMax-1) 
{
g_prgwszKitePackagesPaths[g_piKitePackagesPathsCount] = new WCHAR[MAX_PATH];

::wcsncpy_s(g_prgwszKitePackagesPaths[g_piKitePackagesPathsCount], 
MAX_PATH, 
ws_ApplicationPackagesPath.c_str(),
wcslen(ws_ApplicationPackagesPath.c_str())
);

TRACE_ODS2(L"PackageCache Path (Application) %d %s", g_piKitePackagesPathsCount, g_prgwszKitePackagesPaths[g_piKitePackagesPathsCount]);

g_piKitePackagesPathsCount++;
}
}
} 
else 
{
TRACE_ODS(L"No exe specified");
return false;
}

//-------------------------------------------------------------
fSuccess = pHostEnvironment->NuGetCmdLine_FindEXE();
if (!fSuccess) 
{
//return false;
}

fSuccess = pHostEnvironment->LoadCoreCLR();
if (!fSuccess) 
{
return false;
}

// Start the CoreCLR
pHostICLRRuntimeHost2 = pHostEnvironment->GetCLRRuntimeHost();
if (!pHostICLRRuntimeHost2) 
{
return false;
}

TRACE_ODS(L"Setting ICLRRuntimeHost2 startup flags");

//@@ TODO extract startup flags so a) can compute b) can agument from k.ini

// Default startup flags
hr = pHostICLRRuntimeHost2->SetStartupFlags(
(STARTUP_FLAGS)
(
STARTUP_FLAGS::STARTUP_LOADER_OPTIMIZATION_SINGLE_DOMAIN | 
STARTUP_FLAGS::STARTUP_SINGLE_APPDOMAIN
)
); 
if (FAILED(hr)) {

TRACE_ODS_HR(L"Failed to set startup flagss", hr);
return false;
}

TRACE_ODS(L"Authenticating ICLRRuntimeHost2" );

// Authenticate with either
//  CORECLR_HOST_AUTHENTICATION_KEY  or
//  CORECLR_HOST_AUTHENTICATION_KEY_NONGEN  
hr = pHostICLRRuntimeHost2->Authenticate(CORECLR_HOST_AUTHENTICATION_KEY); 
if (FAILED(hr)) {
TRACE_ODS_HR(L"Failed autenticate", hr);
return false;
}

TRACE_ODS(L"Starting ICLRRuntimeHost2");

hr = pHostICLRRuntimeHost2->Start();
if (FAILED(hr)) {
TRACE_ODS_HR(L"Failed to start CoreCLR. " , hr);
return false;
}

//-------------------------------------------------------------

// Create an AppDomain

// Allowed property names:
// APPBASE
// - The base path of the application from which the exe and other assemblies will be loaded
//
// TRUSTED_PLATFORM_ASSEMBLIES
// - The list of complete paths to each of the fully trusted assemblies
//
// APP_PATHS
// - The list of paths which will be probed by the assembly loader
//
// APP_NI_PATHS
// - The list of additional paths that the assembly loader will probe for ngen images
//
// NATIVE_DLL_SEARCH_DIRECTORIES
// - The list of paths that will be probed for native DLLs called by PInvoke
//

//    
//const wchar_t* property_keys[] = {
//APPBASE,
//TRUSTED_PLATFORM_ASSEMBLIES,
//APP_PATHS,
//APP_NI_PATHS,
//NATIVE_DLL_SEARCH_DIRECTORIES
//};
//

//
//@@ how should we model the following?:
//@@     PackageCache1-System;
//          PackageCache2-PreInstall;
//          Package3-UserProfile-AppData;
//              WebSite\bin
//

const wchar_t* property_keys[] = { 
L"TRUSTED_PLATFORM_ASSEMBLIES",
L"APP_PATHS",
};

const wchar_t* property_values[] = { 
// TRUSTED_PLATFORM_ASSEMBLIES
pHostEnvironment->GetTpaList(),
// APP_PATHS
managedExePath,
};

TRACE_ODS(L"Creating an AppDomain");
//@@TRACE_ODS1(L"TRUSTED_PLATFORM_ASSEMBLIES=%s", property_values[0]);
//@@TRACE_ODS1(L"APP_PATHS=%s", property_values[1]);


hr = pHostICLRRuntimeHost2->CreateAppDomainWithManager(
//Change name of AppDomain to GUID
pHostEnvironment->GetHostExeName(),   // The friendly name of the AppDomain
// Flags:
// APPDOMAIN_ENABLE_PLATFORM_SPECIFIC_APPS
// - By default CoreCLR only allows platform neutral assembly to be run. To allow
//   assemblies marked as platform specific, include this flag
//
// APPDOMAIN_ENABLE_PINVOKE_AND_CLASSIC_COMINTEROP
// - Allows sandboxed applications to make P/Invoke calls and use COM interop
//
// APPDOMAIN_SECURITY_SANDBOXED
// - Enables sandboxing. If not set, the app is considered full trust
//
// APPDOMAIN_IGNORE_UNHANDLED_EXCEPTION
// - Prevents the application from being torn down if a managed exception is unhandled
//
APPDOMAIN_ENABLE_PLATFORM_SPECIFIC_APPS | 
APPDOMAIN_ENABLE_PINVOKE_AND_CLASSIC_COMINTEROP,
managedHostAssembly,                // Name of the assembly that contains the AppDomainManager implementation
managedHostType,                    // The AppDomainManager implementation type name
sizeof(property_keys)/sizeof(wchar_t*),  // The number of properties
property_keys,
property_values,
&dwDomainId
);

if (FAILED(hr)) {
TRACE_ODS_HR(L"Failed call to CreateAppDomainWithManager", hr);
return false;
}

//m_dwDomainId = dwDomainId;

//-------------------------------------------------------------

// Create a delegate to make the initial call into managed code

TRACE_ODS(L"Creating the startup delegate" );

hr = pHostICLRRuntimeHost2->CreateDelegate(
dwDomainId,                     // Domain ID
managedHostAssembly,            // Assembly name
managedHostType,                // Type
managedHostEntrypoint,          // Method
(INT_PTR*)&pHostMain);

if (FAILED(hr)) {
TRACE_ODS_HR(L"Failed to create delegate", hr);
return false;
}

//-------------------------------------------------------------
// Call the delegate to start the application

TRACE_ODS(L"Calling the startup delegate" );

int delegateSuccess = 0;
exitCode = pHostMain(
argc, 
argv, 
pHostEnvironment->GetHostPath(), 
managedAssemblyToStart, 
&delegateSuccess, 
verbose ? 1 : 0, 
waitForDebugger ? 1 : 0
);

//Shutdown

//-------------------------------------------------------------
// Unload the AppDomain
TRACE_ODS(L"Unloading the AppDomain" );
hr = pHostICLRRuntimeHost2->UnloadAppDomain(
dwDomainId, 
true);                          // Wait until done

if (FAILED(hr)) {
TRACE_ODS_HR(L"Failed to unload the AppDomain", hr);
return false;
}

//-------------------------------------------------------------
// Stop the host
TRACE_ODS(L"Stopping the host" );

hr = pHostICLRRuntimeHost2->Stop();
if (FAILED(hr)) {
TRACE_ODS_HR(L"Failed to stop the host", hr);
return false;
}

//-------------------------------------------------------------

// Release the reference to the host
TRACE_ODS(L"Releasing ICLRRuntimeHost2" );

pHostICLRRuntimeHost2->Release();
pHostICLRRuntimeHost2 = nullptr;

//-------------------------------------------------------------
// Unload the managed exe module
if (hManagedExeModule) 
{
::FreeLibrary(hManagedExeModule);
}
hManagedExeModule = nullptr;

return !!delegateSuccess;
}

*/