use assembly="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
use import="Environment"

var PRODUCT_VERSION = '0.1'
var VERSION='${PRODUCT_VERSION}-alpha'
var AUTHORS='Microsoft'

default Configuration='Release'

use-standard-lifecycle
k-standard-goals

var ROOT = '${Directory.GetCurrentDirectory()}'
var SCRIPTS_DIR = '${Path.Combine(ROOT, "scripts")}'
var BUILD_DIR2 = '${Path.Combine(ROOT, "artifacts", "build")}'
var SDK_ROOT = '${Path.Combine(BUILD_DIR2, "KRE")}'
var NUSPEC_ROOT = '${Path.Combine(ROOT, "nuspec")}'
var TOOLS_DIR = '${Path.Combine(SDK_ROOT, "tools")}'
var TOOLS_BIN_DIR = '${Path.Combine(TOOLS_DIR, "bin")}'
var PACKAGES_DIR = '${Path.Combine(ROOT, "packages")}'
var TEST_RESULTS = '${Path.Combine(ROOT, "TestResults")}'
var SAMPLES_DIR = '${Path.Combine(ROOT, "samples")}'
var FULL_VERSION = '${VERSION + "-" + BuildNumber}'
var CORECLR_PATH = '${Environment.GetEnvironmentVariable("CORECLR_PATH")}'

#package-runtime .clean-sdk-dir .copy-bits .tweak-scripts .copy-package-dependencies .copy-coreclr .nuget-pack-runtime target='package'

#rebuild-package .build-mono-entrypoint .build-compile .native-compile .package-runtime

#build-mono-entrypoint target='compile' if='!IsMono'
    directory create='artifacts/build/klr.mono.managed'
    
    @{
        var cscPath = Path.Combine(Environment.GetEnvironmentVariable("WINDIR"), "Microsoft.NET", "Framework", "v4.0.30319", "csc.exe");
        Log.Info("Using csc path:" + cscPath);
        Exec(cscPath, @"/target:exe /nologo /unsafe /out:artifacts\build\klr.mono.managed\klr.mono.managed.dll /define:NET45 src\klr.mono.managed\EntryPoint.cs src\klr.hosting.shared\RuntimeBootstrapper.cs src\klr.hosting.shared\LoaderEngine.cs src\Microsoft.Net.CommandLineUtils\CommandLine\CommandLineParser.cs src\Microsoft.Net.CommandLineUtils\CommandLine\CommandOptions.cs src\Microsoft.Net.CommandLineUtils\CommandLine\CommandOptionType.cs");
    }

#test-package
    var helloWorld = '${Path.Combine(SAMPLES_DIR, "HelloWorld")}'
    var kcmd = '${Path.Combine(TEST_RESULTS, "KRE", "tools", "k.cmd")}'
    var k10Tools = '${Path.Combine(TEST_RESULTS, "KRE", "tools", "k10")}'
    
    nuget-install package='ProjectK' outputDir='${TEST_RESULTS}' extra='-source ${BUILD_DIR2} -ExcludeVersion -pre -nocache'

    @{
        Action<string, string> runWithFramework = (framework, platform) => {
            try
            {
                Environment.SetEnvironmentVariable("TARGET_FRAMEWORK", framework);
                Environment.SetEnvironmentVariable("TARGET_PLATFORM", platform);
                Environment.SetEnvironmentVariable("K_APPBASE", helloWorld);
                
                Log.Info("TARGET_FRAMEWORK = " + framework);
                Log.Info("TARGET_PLATFORM = " + platform);
                Log.Info("K_APPBASE = " + helloWorld);

                Exec(kcmd, "run");

                var commands = new [] { "build" };
                foreach(var cmd in commands)
                {
                    Exec(kcmd, cmd + " " + helloWorld);
                    Directory.Delete(Path.Combine(helloWorld, "bin"), true);
                }
            }
            finally
            {
                Environment.SetEnvironmentVariable("K_APPBASE", null);
                Environment.SetEnvironmentVariable("TARGET_FRAMEWORK", null);
                Environment.SetEnvironmentVariable("TARGET_PLATFORM", null);
            }
        };
        
        Action<string> crossGen = (platform) => {        
            Log.Info("TARGET_FRAMEWORK = " + Environment.GetEnvironmentVariable("TARGET_FRAMEWORK"));
            Log.Info("TARGET_PLATFORM = " + platform);
            
            try
            {
                Environment.SetEnvironmentVariable("TARGET_PLATFORM", platform);
                Exec(kcmd, "crossgen --in " + k10Tools);
            }
            finally
            {
                Environment.SetEnvironmentVariable("TARGET_PLATFORM", null);
            }
        };

        runWithFramework(null, "");
        runWithFramework("k10", "");
        runWithFramework(null, "amd64");
        runWithFramework("k10", "amd64");
        
        
        // Crossgen
        crossGen("");
        crossGen("amd64");
        runWithFramework("k10", "");
        runWithFramework("k10", "amd64");
    }

#ensure-latest-package
    @{
        // We need to re-run the build using the current output
        // Delete the package directory
        foreach (var dir in Directory.EnumerateDirectories(PACKAGES_DIR, "projectk*"))
        {
         Directory.Delete(dir, recursive: true); 
        }

        NuGetInstall("projectk", PACKAGES_DIR, "-source \"" + BUILD_DIR2 + "\" -pre -nocache");
        
        // Nuke the build dir
        Directory.Delete(BUILD_DIR2, recursive: true); 
        
        Log.Info("Rebuilding target default"); 
        Exec("build.cmd", "rebuild-package");
    }
    
#verify-package .ensure-latest-package .test-package target='verify'

#clean-sdk-dir
    directory delete="${SDK_ROOT}"
    directory create="${SDK_ROOT}"

#copy-bits
    var x86Target="x86"
    var x64Target="amd64"
    
    nuget-install package='NuGet.CommandLine' outputDir='${PACKAGES_DIR}' extra='-source AspNetVNext -nocache -excludeversion'
    copy sourceDir='${Path.Combine(PACKAGES_DIR, "NuGet.CommandLine", "tools")}' outputDir='${TOOLS_DIR}' include='*.exe' overwrite='${true}'
    copy sourceDir='${SCRIPTS_DIR}' outputDir='${TOOLS_DIR}' overwrite='${true}'

    copy sourceDir='${Path.Combine(BUILD_DIR2, "klr", "bin", "Win32", Configuration)}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x86Target)}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, "klr", "bin", "x64", Configuration)}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x64Target)}' include='*.exe' overwrite='${true}'

    copy sourceDir='${Path.Combine(BUILD_DIR2, "klr.core45", "bin", "Win32", Configuration)}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x86Target)}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, "klr.core45", "bin", "x64", Configuration)}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x64Target)}' include='*.dll' overwrite='${true}'

    copy sourceDir='${Path.Combine(BUILD_DIR2, "klr.net45", "bin", "Win32", Configuration)}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x86Target)}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, "klr.net45", "bin", "x64", Configuration)}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x64Target)}' include='*.dll' overwrite='${true}'

    copy sourceDir='${Path.Combine(ROOT, "src", "klr.net45.managed")}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x86Target)}' include='*.config' overwrite='${true}'
    copy sourceDir='${Path.Combine(ROOT, "src", "klr.net45.managed")}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x64Target)}' include='*.config' overwrite='${true}'

    @{
        var hostK10 = Path.Combine(BUILD_DIR2, "*", "k10", "**.dll");
        var hostnet45 = Path.Combine(BUILD_DIR2, "*", "net45", "**.dll");

        var sharedSourceAssemblies = new [] { 
            Path.Combine(BUILD_DIR2, "klr.hosting.shared/**/*.dll"), 
            Path.Combine(BUILD_DIR2, "Microsoft.Net.CommandLineUtils/**/*.dll"), 
            Path.Combine(BUILD_DIR2, "Microsoft.Net.Runtime.Common/**/*.dll"),
            Path.Combine(BUILD_DIR2, "Microsoft.Net.Runtime.Interfaces/**/*.dll")
        };
        
        Directory.CreateDirectory(Path.Combine(TOOLS_DIR, "k10"));
        Directory.CreateDirectory(Path.Combine(TOOLS_DIR, "net45"));
        
        foreach(var file in Files.Include(hostK10).Exclude(sharedSourceAssemblies))
        {
            string dest = Path.Combine(TOOLS_DIR, "k10", Path.GetFileName(file));
            File.Copy(file, dest, true);
        }
        
        foreach(var file in Files.Include(hostnet45).Exclude(sharedSourceAssemblies))
        {
            string dest = Path.Combine(TOOLS_DIR, "net45", Path.GetFileName(file));
            File.Copy(file, dest, true);
        }
    }

    copy sourceDir='${Path.Combine(TOOLS_DIR, "net45")}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x86Target)}' include='*managed.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(TOOLS_DIR, "net45")}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x64Target)}' include='*managed.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(TOOLS_DIR, "k10")}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x86Target)}' include='*managed.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(TOOLS_DIR, "k10")}' outputDir='${Path.Combine(TOOLS_BIN_DIR, x64Target)}' include='*managed.dll' overwrite='${true}'
    

#tweak-scripts
    @{
        foreach(var file in Files.Include(Path.Combine(TOOLS_DIR, "*.cmd")))
        {
            var script = File.ReadAllText(file);

            script = Regex.Replace(script, @"REM \<dev\>(.*?)REM \<\/dev\>(\s*)", @"", RegexOptions.Singleline);

            File.WriteAllText(file, script);
        }
    }

#copy-package-dependencies
    @{
        var targetFrameworks = new [] { "k10", "net45" };

        var packages = new[] { "Newtonsoft.Json", 
                               "Microsoft.CodeAnalysis.Common", 
                               "Microsoft.CodeAnalysis.CSharp", 
                               "Microsoft.Bcl.Immutable", 
                               "System.Reflection.Metadata.Ecma335" };

        
        foreach (var framework in targetFrameworks)
        {
            foreach (var package in packages)
            {
                var packageDir = Directory.GetDirectories(PACKAGES_DIR, package + "*").OrderByDescending(d => d).FirstOrDefault();

                if(packageDir == null)
                {
                    Log.Warn("Unable to find resolve " + package);

                    continue;
                }

                string[] candidates = null;

                if(framework == "k10")
                {
                    candidates = new [] { framework, "netcore45" };
                }
                else
                {
                    candidates = new [] { framework, "net40", "net35", "net20" };
                }

                var lib = new DirectoryInfo(Path.Combine(packageDir, "lib"));
                var di = candidates.Select(fmk => lib.EnumerateDirectories("*" + fmk+ "*")
                                                     .OrderBy(d => d.Name.Length)
                                                     .FirstOrDefault())
                                   .FirstOrDefault(d => d != null);

                if(!di.Exists)
                {
                    Log.Warn("Couldn't find version of " + package + " matching " + framework);
                    continue;
                }

                foreach(var fi in di.GetFiles("*.dll"))
                {
                    string packageFileDest = Path.Combine(TOOLS_DIR, framework, fi.Name);
                    File.Copy(fi.FullName, packageFileDest, true);

                    Log.Info("Copying to " + packageFileDest);
                }
            }
        }
    }

#copy-coreclr
    var PROJECTK_DIR='${""}'
    @{
        if (String.IsNullOrEmpty(CORECLR_PATH))
        {
            Func<string, long> getVersion = version => {
            var dash = version.LastIndexOf('-');

                if(dash != -1)
                {
                    var lastToken = version.Substring(dash + 1);

                    if(lastToken.StartsWith("t"))
                    {
                        return Int64.Parse(lastToken.Substring(1));
                    }

                    return Int64.Parse(lastToken);
                }
                return Int64.MaxValue;
            };

            string packagesDir = Path.Combine(Directory.GetCurrentDirectory(), "packages");
            PROJECTK_DIR = Directory.EnumerateDirectories(packagesDir, "ProjectK*")
                                    .OrderByDescending(getVersion)
                                    .First();
                                          
            Log.Warn("The environment variable CORECLR_PATH is not set, using " + PROJECTK_DIR);
        }
    }

    copy sourceDir='${CORECLR_PATH}' outputDir='${SDK_ROOT}' overwrite='${true}' if='!String.IsNullOrEmpty(CORECLR_PATH)'
    copy sourceDir='${Path.Combine(PROJECTK_DIR, "Runtime")}' outputDir='${Path.Combine(SDK_ROOT, "Runtime")}' overwrite='${true}' if='!String.IsNullOrEmpty(PROJECTK_DIR)'
    copy sourceDir='${Path.Combine(PROJECTK_DIR, "Framework")}' outputDir='${Path.Combine(SDK_ROOT, "Framework")}' overwrite='${true}' if='!String.IsNullOrEmpty(PROJECTK_DIR)'
    
    @{
        var files = Files.Include(Path.Combine(SDK_ROOT, "Framework", "**", "*.dll"));
        foreach (var binary in files)
        {
            File.Delete(binary);
            Log.Info("Deleted " + binary);
        }
    }

#nuget-pack-runtime
    @{
        var allPackages = Path.Combine(BUILD_DIR2, "**", "*.nupkg");
        var excludePackages = Path.Combine(BUILD_DIR2, "**", "Microsoft.Net.Runtime.Interfaces*.nupkg");
        foreach(var packageFile in Files.Include(allPackages).Exclude(excludePackages))
        {
            File.Delete(packageFile);
        }
    }
    
    copy sourceDir='${NUSPEC_ROOT}' outputDir='${SDK_ROOT}' include='*.nuspec' overwrite='${true}'
    nuget-pack nuspecFile='${nuspec}' packageVersion='${FULL_VERSION}' outputDir='${BUILD_DIR2}' extra='-NoPackageAnalysis' each='var nuspec in Files.Include(Path.Combine(SDK_ROOT, "*.nuspec"))'

macro name='NuGetInstall' Package='string' OutputDir='string' Extra='string'
    nuget-install package='${Package}' outputDir='${OutputDir}' extra='${Extra}'
